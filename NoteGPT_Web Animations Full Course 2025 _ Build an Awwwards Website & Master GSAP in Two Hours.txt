
00:00:00
Think front-end development is dead, AI is taking your job, and no code tools are putting you out of business. Think again. Sure, AI can spit out cookie cutter UIs, but it can't craft experiences worthy of awards or create interactions that make people stop and say, "How the heck did you just pull that off?" This is where real front-end skills and real front-end developers step into the spotlight. Hey, I'm Adrian and today I'll show you just how alive and essential front-end development


00:00:31
still is. You're going to master smooth cinematic animations that transform websites from well, it's working to mindblowing. Your journey to becoming a standout developer starts right here by mastering GSAP, the powerful animation library trusted by top tier agencies and creatives worldwide that as of recently became completely free. People pay thousands for these skills, but today you'll get them for free. I'll teach you what GSAP actually is and why it's so powerful. some pro tips, tricks, and


00:01:05
common mistakes, and how to seamlessly integrate Gap with React, Vue, Nex.js, or any other front-end framework with plenty of engaging demos to keep things exciting and hands-on. And because absorbing all of this info in one go can be tough, I've put together a free GSAP cheat sheet you can download right now. Keep it handy whenever you're building out your next jaw-dropping animation. So, I'll leave the link down in the description, but theory alone won't cut it. That's not how I roll. Once you're


00:01:33
comfortable with the basics, we're diving head first into creating a stunning realworld project. Mojito cocktails, a landing page so smooth it just might slide off your screen. Think scroll triggered animations, immersive parallax effects, and silky smooth transitions. The kind of stuff you drool over when browsing awards. Before we dive in, this crash course will give you a solid start with GSAP and show you how to create beautiful fluid animations like this cocktails website we're building today. But if you want to truly


00:02:06
master GSAP and learn how the world's top companies build those mindblowing realworld animations you see on sites like GTA 6's landing page. Well, that's why I've created the ultimate GSAP course. Inside the full course, we go way deeper. You'll actually build a full-blown GTA 6 landing page clone from scratch using advanced GSA techniques, scrollbased animations, timelines, performance optimizations, real project structure, and tons more. You'll also get access to this special app that


00:02:44
references all of the animations you've learned so far. and it also contains some challenges. But within the lessons is where the real magic happens. Here you'll be able to see exactly how they behave in real time and how things work behind the scenes. The crash course you're watching right now will give you a taste, but the full course will turn you into a pro. So, if you're serious about leveling up your animation skills and want to learn how real companies build these experiences, the link is


00:03:14
below. Now, let's get started. Now, before we dive into the build, I want to make sure you have a solid foundation. I've prepared a fast-paced, hands-on GSA crash course to get you up to speed with everything you need to know and to show you just how intuitive and powerful this library really is. So in the next few minutes you'll learn how to animate elements using GAP from to and from to methods. How to control your animations with scroll trigger. How to stagger animations for maximum visual


00:03:58
impact. How to animate text like a pro using split text plug-in. And how to sequence animations one after another with GSA timeline. Think of this as your GSA toolbox. Once you've got this down, building realworld jaw-dropping experiences will become so much easier. Let's jump in. I prepared a quick workshop for you and I've linked it for you in the description. Download it, open it within your Visual Studio Code, and then we can install all the necessary dependencies by running mpm


00:04:32
install. So, let's go ahead and run the application by running mpm rundev to see what we have on it. And then we can hold the command key and click on this link to open it up. As you can see, I prepared seven different demos that teach you seven most important GAP concepts. So, let's dive into the first one by clicking right here. And let's explore gap.2. G.2 method is used to animate elements from their current state to a new state. It's similar to gub.fro, from. But the difference is that the gap 2 method


00:05:06
animates elements from their current state to a new state while gap from animates elements from a new state to their current state. And of course, you can read more about it if you head over to the documentation page. Basically, you can see how it works right here. You target a specific element by providing the identifier and then you specify the properties that you want this element to take after the animation runs. So, we are changing the rotation and the X position throughout the duration of 1


00:05:35
second. So, now you've seen the demo, right? You could have done on your own without me, but see this box right here? Now, we'll animate it together to solidify what we just learned. So going back to the code, we can split our terminal and install a new package by running mpm install gap as well as add gap/react which will allow us to start adding those animations. Once that is done, we can head over to our pages and then gap 2 as that is the first element we want to animate. In this case, I want you to


00:06:10
animate the box that we have right here below. So if you scroll down you can see a div that has a class name of vwhw and then bgb blue 500 which makes that a box and here we have an id of blue box. So let me teach you how to animate using gap in react. Right below this to-do we can say use gap coming from gsap react. This is a special hook which looks and behaves a lot like use effect. Essentially, you define a callback function and then a dependency array on when this has to run. And within it, you


00:06:50
can use gap to then animate the elements you want. So we do that by saying gap which you have to import from the original GAP package. 2 and then the first parameter to the method is the target you want to animate. In this case, we can target it by ID by saying blue box. Then the second parameter are variables which you want to animate. So you can expand an object and let's do something like X is 250 pixels. So we animate from X of zero of course by default to X is 250. So now if you go back to your page


00:07:29
and reload, you can see how nicely this animates. And just so we can see our animation happening in real time at all times without needing to reload the page, we can add a repeat of minus one as well as a yo-yo property set to true, which will make the animation reverse on every other cycle. So, as you can see, now it's going back and forth. Let's pull this to the side so we can continue animating while we're writing the code at the same time. There we go. That's much better. Now let's also give it a


00:08:00
bit of a rotation property of 360. And you can see now it completely rotates. We can also increase the duration to something like 2 seconds. If you do that, it's going to move much slower. And we can also give it a special ease property which defines how the animation happens. As you can see immediately, you get a lot of different properties you can choose from. For example, bounce in. If you save it, you can see now it kind of bounces in and then stops. You also have bounce out, which going to make it bounce at the


00:08:33
end. There's a lot of these different easing curves that you can decide to use. There's also circle back and so much more. In this case, let's use elastic. As you can see, it looks like it's on a spring right now, which you have to pull and then move back and forth, which gives it a very interesting effect. But with this in mind, you just learned how to use one of the fundamental methods in GSAP, which is GSAP.2 property, which accepts an ID, which is an identifier, and then properties you want to apply to the


00:09:05
element you're targeting. You also learned how to apply animations using the use GSA hook, and GSAP within React. So, with that in mind, let's go back to the homepage and navigate to the second method of the day. Gap from, as the name suggests, GSAP from is used to animate elements from a new state to their current state. Similar to GUB 2, but the difference is that the from animates from the new to the current, while GUB 2 animates from their current to a new state. Of course, you can find more


00:09:37
information within the docs, but for now, let's implement it in action. I'm going to go back to gap.2 and copy this entire part. Then I'm going to navigate to GSAP from and simply paste it right here below. Of course, not forgetting to import the use GSAP as well as GSAP. Now, if we modify the method from to from and modify the ID from blue to green and save, you can see that it started moving from the back and then going to the front. In this case, let's explore a bit of a different


00:10:15
ease, one I like to use often, which is power one.in out. This one starts with a lot of power and then slows down. As you can see it right here. But the most important thing is that now it starts from the position 250 pixels in. If I reload, see how it started from the right side moving to the left. That is the only difference between from and to. The next method of the day is gap from to which as the name suggests is used to animate elements from a new state to a new state similar to from and to methods


00:10:51
but the difference is that here you can define both states. So if we scroll down we can copy the entire thing we have here and navigate to from two. So let's paste what we copied. Import the hook as well as gap. We can modify the method from from to from to. And you still pass a specific identifier, but this time you have two different objects you can modify. We have the first object, which is the from object, and then we have the two object, which accounts for the two properties we want to implement. So,


00:11:27
let's try to animate it from an X of zero and a rotation of zero with something like a border radius of 0% as well. And we're going to animate it to 250 repeat minus one. And let's also add a border radius of 100%. And we can also modify the ease to something like bounce out to explore another one. Now if we modify the identifier from green box to red box and save it. Now you can see how it turns from a square into a circle and then comes back. So we're modifying the rotation and the X and the border radius


00:12:09
to zero at the start and then at the end we set it to 100 which essentially makes it a circle. This is pretty useful when you want to modify both the start and the end of an animation. With that in mind, those have been the three base GSAP methods. But let's explore what else we have in store. Next one on the list is the GSAP timeline. And the GP timeline is used to create a timeline instance that can be used to manage multiple animations. Again, it's similar to two, from and from two, but it is used to manage


00:12:45
multiple animations while all of these manage just one element from their current state to a new state. Of course, we can open up the docs to learn a bit more about it. And in this case, you can see that they consider it a sequencing tool that acts as a container for the other animations we have explored. It allows you to have complete control and manage the timing of an animation. So instead of doing something like this, first do X 100, then do Y50 and then change the opacity to zero. You can create a timeline and then you can


00:13:19
modify the elements to move on that timeline. You can also control the whole thing easily by pausing it, resuming it, reversing it, and so much more. So with that said, let's animate this yellow box and also include the play and pause button. So we can navigate over to GAP timeline and you can see at the bottom as we always do there is a div that has an id of yellow box. So first things first when creating a timeline we have to define it by saying const timeline is equal to gap which you have to import


00:13:55
from gap timeline and then you call it like this. Next, you can also pass the options object to give it some properties like repeat minus one, repeat delay of something like 1 second, and yo-yo to true. We already learned what this does. It simply makes the box move left and right. It simply makes the animation repeat. So, we don't have to reload the page to check out the animation. Now that we have the timeline defined, we can use the same use gap hook we have used not that long ago. define the


00:14:29
callback function as well as the dependency array. Now within it, we can use the timeline.2 property instead of using the gap.2 property and it works in the same way you have seen it before. It's just timeline.2. You then define the identifier which in this case is the yellow box and the second parameter are the variables you pass to it such as the X is 250, rotation is 360, border radius is 100%. Duration is 2 and then ease is back in out. Again, this doesn't matter too much right now, but we're just playing with


00:15:12
the way that the animation actually executes. So, if we save it now, you can see how it goes from one end to another and comes back. Now, what we can do is we can also say timeline. Again, target the same yellow box and then provide another set of variables we want to apply to this animation such as X500, scale of 1, rotation of 360, border radius of something like 8 pixels, duration of two, and ease of back.in out. Now, if I save this, you can notice that it's yellow and then it goes further out of the screen. I'm going to


00:15:56
zoom this out a bit so you can see the full animation. First, it goes to 250, waits a bit, and moves to the end and then it returns. Now, this is a bit similar to using the from and to or the from two. But what this allows us to do is to add additional animations in the middle. So, we can say timeline.2 two once again where we target the yellow box. And this time we can for example do the Y of 250, scale of two, rotation of 360, border radius of about 100% and duration of two as well as the ease back dot in


00:16:40
out. Now if we save this we have added a third animation to the mix where now it will actually go down out of the screen move back and then it's going to come back again. So these animations are happening in a row one after another which gives you a lot of possibilities to control the entire timeline. Now another thing you can do here is of course play and pause it because you have complete control over the timeline. So let's head over to our play and pause button which is right here. And let's


00:17:13
expand this on click functionality. We can define an if statement and say if timeline.paused is true then we want to trigger the timeline. And also else vice versa then we want to run the timeline.pause. So if we do this and save now you can click play pause and completely pause the execution of the animation then you can trigger it again and it works. So I think you can see the benefits of running animations within a timeline. You have more control. Now let's move over to the fifth method in the GSAP


00:17:53
repertoire. Stagger. Gap stagger is a feature that allows you to apply animations with a staggered delay to a group of elements. By using the stagger feature, you can specify the amount of time to stagger the animations between each element, as well as customizing the easing and the duration of each individual animation. This enables you to create dynamic and visually appealing effects such as staggered fades, rotations, movements, and more. And of course, you can find more within GUB Stagger documentation. They even


00:18:24
prepared a little video, but in essence, it is as easy as using the stagger property. So, let's explore it in action by navigating over to the stagger file. In this case, if you scroll down, you'll notice that we don't have a single box with an ID of box. Rather, we have multiple divs that all have the same class name, stagger box. So, instead of simply using an ID, we'll use the class name as an identifier. So same thing goes we can use the use gap hook create a callback function


00:18:59
and then we can use the gap.2 method and in this case we can import gap from gap. Now you might say hey we already learned two but we haven't used stagger. Well stagger is just a property you can apply to any animation. So we'll use two to show this out to explain the stagger by targeting the stagger-box and then we can provide the options. In this case we can do the same thing we've done before such as Y of 250 rotation of 360 border radius of 100% to turn it into a circle. We can add a repeat of minus one


00:19:42
as well as a yo-yo of true. Now if we save this you can see they all follow the same animation as we're targeting all of the elements simultaneously. But what if we want them to animate one by one? Well in that case we can provide a stagger property of 0.5 let's say. So now we can save it and you can see that now after half a second each one of this animates one after another. But it doesn't end there. We can also apply more complex stagger properties by defining stagger as an object. Here you


00:20:19
can provide the amount which is the amount of time to stagger the animations between each element and we can say something like 1.5. Then you also have access to something known as a grid. Grid selects the number of columns and rows in a grid. So you can say something like 2 1. Then there's also the axis and you can choose the axis along which to stagger the animations. In this case we can say Y but you could also say X in which case they all happen at the same time. Next you can also apply the ease


00:20:52
which in this case we can do something interesting like cir dot in out and now kind of they happen in a circle. And finally this is the most interesting one. You can define the from which is the starting position of the staggered animation. So instead of starting from the start or the end, we can say center. So this will make it start from the central staggered box. As you can see, now it happens from the start and moves until the end. And you can also see how they're doing two and then one and so


00:21:22
much more. So you have complete control over how you want to stagger your elements. This is great. So now you know how stagger works and how you can use it when you have multiple elements which you want to animate. and let's call it a dance of sorts. The next feature on our list is the scroll trigger which is used to trigger animations based on the scroll position. So as you scroll you can animate specific things once you reach a specific point in time. So for example, scroll down to see the


00:21:51
animation and then only after you reach a specific point we want the animation to start. So let's first open up the documentation page and I always advise you to read the docs for anything you're doing. There's also a quick video right here. And the simplest way is to attach a specific target which when it enters the viewport or the screen, then the animation happens. Or you of course have much more control over when what over when the animation triggers. In this case, we can go back


00:22:19
and go to GSAP scroll trigger. And let me show you how to implement it. First of all, it's very important to note that gubcroll trigger is a plug-in which means that we have to initiate it at the top by saying import scroll trigger from gap all and then you can do gsap which we have to import from gapregister plugin and then you pass that scroll trigger. This will make it work. Next with triggers you also have to define a ref a reference. So we can say scroll ref is equal to use ref coming from react.


00:23:02
This is not gap related. This is just react. Then we can use the same old use gap hook coming from gap react which we can define like we have done so far. Now in this case if you scroll down you'll be able to see that we have some boxes right here. Now, if you scroll down, let's attach that ref to our boxes. So, if we scroll here, you can see that we have two boxes, the scroll pink and scroll orange. And we can attach a ref to this div wrapping both of them by saying ref is equal to scroll ref like


00:23:39
this. Now, we can scroll to the top and we can start animating. So first let's get access to those boxes by saying const boxes is equal to gap utils dot to array and to it we pass the scroll refur. So this is how you can get the children using a react ref. Next we can also run the boxes dot for each. So for each box we want to do something and that something will be a simple gap.2 animation where we target each individual box and for each one we apply some specific properties. In this case we can say X is something like


00:24:28
150. Rotation is 360. Border radius is something like 100%. Scale is 1.5. We have learned that already, right? So now if we scroll down, you can see that they basically already turned into circles even though we didn't see it at all because we were at the top when the animation was happening. Not too useful, right? Typically, you want to have some animations when you scroll up to a specific point. Like if we're here, we can see it, sure, but the user will come from top and then we'll start viewing


00:25:03
this at the bottom. So this is where scroll trigger animations come in. To this GAP 2 property, we can apply a scroll trigger which is an object to which you can pass a trigger and then this one will be a box. So one specific box comes into view, we want to start the animation. Let's see that once again. If I start scrolling down already, it's a circle. But that's because we're missing something important. We're missing the start of the animation which we can define as bottom bottom. So when the bottom of the


00:25:39
box hit the bottom of the viewport then it will animate. And we can also define when it will end and it will end when the top of the box hits 20% of the viewport. We also have something called scrub which we can set to true which makes the animation smooth. And below the scroll trigger, we can also define the ease of power one dot in out. And the reason why the scroll trigger animations are not working is because I misspelled it as scroll instead of scroll with a double L. So if we fix this now, check this out. I'm going to


00:26:13
scroll to the top, reload the page, and start scrolling down. So now as we enter the viewport slowly, you'll see how this starts as a box because that's what it styles say by default and then slowly it starts moving to the right and it starts applying the rotation, border radius and scale as we scroll. Check this out. Interesting, right? And also it goes back immediately. Now, another thing is that since we're mapping over those boxes, we can apply a bit of math to each one. So, instead of just moving it


00:26:51
x 150 for each one, we can multiply that by boxes dot index of a specific box. So, this will already applied a bit differently because the second one has an index of one. And we can also give it some default value like + 5. So now if we start scrolling down you can see how nicely they animate and exit out of the screen. We come back they are back and of course you can keep playing with these value like top 30% which will make them go away much sooner or like something like top 10% which will make


00:27:26
them in the screen for a longer period of time. It's up to you to start playing with this. And I just noticed we don't need a comma right here. It's just bottom bottom. So like this. Yeah, that's great. Another thing you can add when you're animating using the scroll trigger is if you go all the way to where you end the use gap function which is here. You can also provide a second parameter of scope is scroll ref like this. That way it will know exactly when the animation has to happen. So now


00:27:58
I'm sure you have already noticed how useful gap is specifically simple properties like gub 2 staggering and so on. but only when you pair it with scroll triggers, which will do a lot within this video. And it's also covered in a lot of depth within our ultimate guide, which you can find in the description down below, completely for free. You notice how it all starts coming together when you combine all of these properties. And finally, we have GAP text where I'm going to teach you how to animate text elements with GSAP.


00:28:29
So to animate text, you can use all the methods we have explored so far. The only thing you have to do is integrate the text plugin. You can see it in the docs. Basically, you can add the GUB 2 and then add the text you want to animate. You also have some special properties for animating text elements. So, let's head over to text. And you can see an H1 here that says GAP text, but it's nowhere to be found on the screen. It's kind of like it's being hidden, right? And that's because it is. At the


00:28:59
start, the opacity is zero. So let's go ahead and animate it in. We're going to use the same old tips and tricks like use gap coming from gap react where we have our callback function. Then we will define gap.2 which we have to import from gap. We target the text element by id of text. And then we provide some properties like ease which will be power one.in out. Once again, you can go without this or you can find the ones that you like and then add different eases. And then I'm going to add opacity of one as well as Y


00:29:39
of zero. So this is nothing new, right? We're just changing some properties using GAP 2. And you can see how nicely it slides in. Great. Now, let me also teach you how to animate the paragraph. You can see this parak class name right here. It combines all of these properties that you can see. So let's add a gap from two in this case and we can target the parara which is the paragraph and then as you know with from two you have to define two different objects and at the start this text is visible we


00:30:15
didn't apply an opacity zero like we did here. So you can apply it here in from opacity zero Y of 20 and then of course it's going to break until you provide a second object where you can reset the opacity to one and Y to zero. So now you can see how nicely it fades in. We can also apply other things we learned such as the delay between the elements as well as the stagger of 0.1. So now different paragraph elements are going to animate one after another. And with that we came to the end of this


00:30:51
little GAP workshop. All right, you just flew through the fundamentals of GSAP and saw firsthand how quickly you can make things on your site move. And we're just getting started. Now it's time to put your skills to the test by building a real project from scratch. A visually stunning landing page for a brand called Mojito Cocktails. We're talking scroll triggered animations, immersive parallax effects, and elegant transitions that'll have your site looking like it belongs on awards. We'll build four additional


00:31:25
sections loaded with even more animations. You can watch the whole thing on jsmastery.com with interactive live demos for hands-on experimentation, byite-size challenges to reinforce key concepts, quizzes designed to lock in your learning, step-by-step git commits to track your progress clearly, and deep dives later on. So, first you build this entire cocktail website to get you going with Gap. But then we take a step back and dive under the hood of how GE works and how you can become a top 1% GE


00:31:58
developer. The link is in the description, but if you want a taste, let's bring this project to life first. Starting with setting up the app. Before we start developing this amazing animated Gap Cocktails landing page, I first want to go over the tech stack that we'll use to make it happen. Of course, the star of the show will be Gap, which as of recently became completely free for everyone. It is one of the only and the best JavaScript animation libraries out there. And in this video, you'll learn how to build


00:32:33
this website using it. But if you want to take it to the next level, go ahead and check out the ultimate GAP course linked down in the description. Now, I invite you to use any framework or library you want to build this application. For example, you could use Nex.js or maybe you could use Vue. But in this case, I'll be using React. Either one works. You can follow along and build it using your library. But the simplest way to spin up a React application is using a build tool called VIT. So head over to vit.dev and click


00:33:09
get started. And then if you scroll a bit down, you'll see the installation command to spin up your project. So let's copy it and head over within your IDE. In this course, I'll be using WebStorm. Webstorm is a powerful IDE that as of recently became completely free for non-commercial use. Before you needed to pay a lot of money to be able to get all the features that you can get out of an IDE as to when compared to a simple text editor, but now you can download it completely for free and


00:33:40
follow along and see exactly what I'm seeing. So later on, if you see some cool feature right here built into my IDE, well, you know it's coming from WebStorm. Oh, and with WebStorm, you can also get access to Juny, which is a smart coding agent that does more than just recommend the next line you want to type in. It is so smart that it can modify the entire codebase given your prompt, increasing your productivity more than ever. Once again, the link for Juni as well will be down in the


00:34:06
description. I'll be using it later on throughout this course, so it might be good to just download it right away. With that in mind, I'll just paste the mpm create vit add latest command into my terminal. I just created a new empty folder on my desktop and called it JSM Gap landing. And I'll add the dot slash at the end because I want to create a new React project within the current repo. So, press enter. It'll ask me whether I want to install the following packages. So, I'll say yes. And now we'll have to


00:34:37
answer a couple of questions. First I'll say ignore files and continue. Then I'll choose my framework which will be React. And then we have to choose the variant that we want to use. In this case I'll go with JavaScript. And that's it. Now we just have to run mpm install. And as you can see my webtorm automatically tells me that it can do that for me. And once the packages are installed you can just run mpm rundev to spin up this project right within our local host 5173. If you do


00:35:07
that, you should be able to see just a very simple Vit and React boiler plate. But now we want to clean it up so we can create a clean slate so we can start working on our animated gap website. So back within our code, let's remove the existing app.jsx within the source folder. Also remove the app.css file and remove the entire assets folder since we won't be needing these default assets. Also remove all of the styles from index.css because we're going to replace them with our custom tailwind classes very soon.


00:35:42
And now just so we can show something on the screen, create a new app.jsx and run rafce right within it, which will quickly spin up a new react air function export component that looks something like this. If you did that properly, back on your localhost 5173, you should be able to see just a single app text. Now, let's also install the most important dependency needed to run this project and that is of course gap. So, I will actually open up a new terminal window and I'll call it terminal and I'll rename our first one


00:36:18
to app because on this one we want to keep running the app and here we want to run additional commands. So let's install by running mpm install the gap library at gap slreact. And we'll also need an additional library called react responsive which will help us with the animation logic and the layout behavior based on the screen size and press enter. This will now install these packages and you can immediately notice that GAP is super lightweight because it got installed in 1 second. Now that we installed GSAP, we


00:36:54
have to put it to use and we can do that by using its two plugins. So right here on top of our app, I will say import. And I'll get here the scroll trigger as well as split text plugins coming from GAP all. And we want to register these within the app by saying gap.register plugin. And then we want to pass the scroll trigger as well as the split text. We want to do it within the app because these gap plugins aren't automatically active. You have to register them. And this line makes sure


00:37:31
that both plugins are ready to use globally across your application. You only need to do this once. So putting it in the app file is a great choice. The scroll trigger plugin will allow us to animate things based on the scroll position like pinning, scrubbing, or triggering. And split text will allow us to break text into individual words or characters for detailed text animations. Great. So now that the GSAB basics are set up, let's also set up Tailwind. Tailwind CSS is a utility first CSS


00:38:04
framework packed with great utility classes that are going to simplify our styling but still allow us to make our application as unique as ever. So let's follow its getting started guide to quickly install it. We're using Vit so that is super simple. We just have to copy this command and paste it into our terminal that is mpm install tailwind css and at tailwind css/vit. Once you install it, you want to configure the vit plugin by modifying the vitconig.ts file. So let's copy this import and let's head over into


00:38:43
vit.config.js. And alongside the React plugin, right after it, we also want to add Tailwind CSS, which is coming from Tailwind CSS/V. After that, we want to head over into our index.css and say add import tailwind CSS, which will allow us to use all of the Tailwind styling functionalities. And to test whether the Tailwind CSS installation is working within this div, let's create a new H1 and give it a class name of something like text-3XL and text- indigo 300. And we can make it say something like


00:39:26
hello GSAP. Now, just before we test it out, let's also make sure that we have access to this GSAP coming from the GSA library. There we go. And back within the browser, you should be able to see a text that is larger, colored, and says, "Hello, Gap." Let me zoom it in for you so you can see it a bit better. Perfect. Now, to be able to style the rest of this application more easily, we can immediately make our life easier by creating a couple of classes called utility classes. See, a utility class is


00:40:01
something that looks like this. You say at utility and then define the name of that class name such as flex center. Then you apply a specific number of class names that would be added together as soon as you use this flex center. For example, you want to make it a flex container justify center and items center. So if you do this, head back over into app and now give this div a class name of flex center which is not a default class but it is a utility class we have added right now you can see that now


00:40:43
it's fully centered. So to make the styling of our application more convenient in the description down below I'll provide a link to a video kit for this project. Then if you scroll a bit down, you'll be able to see a complete index.css file. Copy it and override your current index.css. First, we import a custom font from Google fonts at the top. Then we import Tailwind CSS, and then we add an additional font face, allowing us to load a local font from our public folder. Then we give it a name so we can


00:41:18
reference to it later on within our Tailwind CSS classes. I'll show you how we can add it to our public folder very soon. After that, we define a theme. You can define different colors such as the primary yellow color or maybe an off-white, and then we set different fonts. We do a bit of a cleanup on the HTML and body tags where we set the width to 100, change the background color to black and the color to white, and set the scroll behavior to smooth. And then we have a bunch of these utility classes which are


00:41:51
on their own not providing anything special but are making the styling of our application simpler. For example, if you want to apply a gradient with all of these classes, we just have to say text gradient. There are a couple more of these ones such as the masked image and then the components themselves. So if we want to automatically style a nav, as soon as we use this tag, we'll automatically apply specific class names to it. and the elements within it as well. For example, the P tag within the


00:42:20
navbar will automatically have this font applied. As we use some of these classes later on, such as this noisy class, which will add a background image that will make the background feel a bit old school, well, I'll show you that we use this class and then explain exactly what it is doing. But for now, what matters most is that you have access to this index.css file right here within your code. Now if you close it and get back to your app file and give this div an additional class name of h dash which


00:42:53
stands for height. But then if you use quer brackets we use this in tailwind when you want to provide a custom value such as 100vh which stands for full vertical height. If you apply this change and save it and then go back in the browser you should see that now our text should be very big. Well, at least it would be big if you zoomed in at 500 like I did. And it should be entirely centered on a dark background, which means that you have successfully implemented all the styles and set up the initial configuration of the


00:43:27
application, which means that immediately in the next lesson, we'll be able to dive into the first part of the UI, which in this case is a simple navbar. But now that you have actually set up the application, that's something to be a proud of. And to start forming good habits, it is recommended that we always commit something to GitHub, no matter how small the feature is. So since I want to teach you the best practices, let's actually create a GitHub repo for this project from the start. Head over to github.com/new


00:43:57
and create a new repo, which I'll call gap cocktails. Make it public or private, whatever you prefer, and click create repo. Next, you'll have to follow the following steps in order to be able to push it. But I think we only need to copy this get remote add origin because it contains our unique URL. So copy this entire line. Go back to your application and open up your terminal here. Type get init dot get commit dash m initial commit get branch- m main then paste the get remote add origin and


00:44:46
finally say get push-u origin main which will push the code you have so far on your branch. So, if you head back over to GitHub and reload the page, you can see that your code is now live right here under the initial commit. Now, we're doing this for a couple of reasons. First of all, to create good GitHub habits where you can actually push your code after every feature. Second of all, if some recruiters take a look at your projects, it's not good to just see a final commit with all the code. Rather they want to


00:45:21
explore the commit history to see you have actually been committing consistently which means that you yourself have developed the project. If you do it properly it should look something like this where for my previous project I have about 20 commits where you can see where we have implemented every single feature. And another reason why I'm doing this is because on jsmastery.com you can watch this same course but split into lessons. So, if you find this course and click resume where you left,


00:45:50
at the bottom of each lesson, such as this project setup we're on right now within YouTube, you can check out the lecture summary, the transcript, some notes, but also a special commit for each one of the lessons. So, you can know exactly which code has to be implemented for that lesson. That'll look something like this. Like if you implement a navigation bar, you can see that we're only adding the navbar and nothing more. That way you can follow along and even if you get lost, you'll


00:46:20
be able to get back on track. Oh, and by the time you're watching this video, the ultimate GAP course will have been released. So go ahead and check it out as it might provide you some additional insights into how GSAP works and then you can build out this cocktails website and truly understand the behind the scenes of the animations that GSAP powers. So great job on completing the most boring part of this course, the setup. Now immediately in the next lesson, you'll develop your first UI


00:46:51
component. Let's start with the first piece of our UI, the navbar, the component that will set the stage for the navigation and include a smooth scroll animation powered by Gap. So create a new folder right here within the source folder and call it components. Then within components, create a new file and call it navbar.jsx. And within it, you can run rafce to quickly spin up a new navbar component. Now that you've created it, head back into the app.jsx, clear this div that we have right now. Instead, create a main


00:47:36
tag, which means that this is the main part of our content. And within it, just render a self-closing navbar component coming from /components/navbar. If you've done that properly, you should be able to see just the navbar at the top left of your browser. Now, I'll put my browser side by side with my editor so we can see the changes that we make live. Let's head over into that navbar, turn it into an HTML 5 semantic nav tag with a div. And within this div, we can render an anchor tag that'll have an


00:48:07
href pointing to hash home. So once we click on it, it'll lead us to the hero section. I'll give it a class name equal to flex items center and a gap of two. And right within it, we can render a p tag that'll render the name of our imaginary cocktail bar. For now, I'll do something like velvet poor. There we go. And this will be a part of our logo. I'll add the logo soon, but before that, head over below the anchor tag and create a new ul, an unordered list. within it. Open up a new dynamic block


00:48:44
of code and create an array that'll have different objects within it. Each one of these objects will have a title of something like about us. And it'll also have an ID so that we can scroll to it, which will be something like about. And now we can create a couple of these objects right here. Each one within its own line. But if you do that, you'll quickly notice that your application or your code would get pretty cluttered. So instead, I like to do those within a new file called constants. So right here


00:49:20
within the root of our application, create a new folder and call it constants. And within constants, create a new file called index.js. And within it, we can create a new const nav links and make it equal to an array where we can have those multiple objects. Each one having an id of cocktails in this case as well as a title. And now we can do the same thing for for example the about section. So ID is about and title is about us. Now you want to export that just so we can use it within the other


00:49:58
file. And if you head back over to our navbar now, you can just simply say nav links. Make sure to import it from constants index.js map. And you can now map over each one of these links. And then for each one, you can automatically return an LI, a list item. Now, what do I mean by automatically return? I mean using parenthesis right here instead of curly braces. Because if you used curly braces, then you would have to add a return keyword right here. But if you use just the parenthesy, it'll return


00:50:32
this automatically. This LI, since we're mapping over it, has to have a key. And the key will be equal to link ID because it's unique. And within the LI, we can render the anchor tag with an href of dynamic template string of hash and then the link ID. and it'll render the link.title within it. So, if I save this, you can see that now it says Velvet Pore and we have cocktails and about us, which are the two links within the nav links array. Now, on top of just having the two links, we want to have


00:51:06
more of them. And just so we don't have to type all of them by hand, I actually want to provide you with the complete constants file. So, open up the video kit, scroll down, and there, just below the index. CSS, you'll also be able to find the constants index.js file. Copy it and paste it right here. You'll notice that alongside the nav links, which we have right here, we also have a couple of other things that we might want to render later on, such as the cocktail lists, mocktail lists, profile


00:51:38
lists, and feature lists. These are all just different arrays of text that we want to display on our landing page just so we don't have to type them by hand and put them within our JSX. We're keeping them in one single place. So that if you maybe give this website over to a cocktail website owner, they can come into this file and just change their opening hours themselves. They don't necessarily have to dive right into the code and mess with the code right here. Perfect. Oh, and within this


00:52:08
video kit, you can also find a Figma design. So, go ahead and click on it, and you'll be redirected to a Figma design that our JSM designer has prepared specifically for you completely for free, where you can find the entire design of this application right here. And you can go ahead and develop it on your own if you want to, or you can follow along with this course. One thing that you'll notice right here is that this website has a lot of assets starting with the small ones such as this logo right here next to the Velvet


00:52:39
Pore which is the title of the company on the top left. Also these leaves, maybe this primary video that we want to animate, as well as some other leaves and more photos that we want to display of just people having a good time and enjoying our cocktails. So, in order to be able to get all of these assets, you could go ahead and explore the design, click on it multiple times until you get to the actual image, and then you can just export it as a PNG, JPEG, or something else. That's totally okay. But


00:53:12
these assets have long names, and it's easy to get lost into all of this naming, and it will take some time. So, I took some of my time to save the time for you. And I collected all of these assets into a single zip folder that I shared within Google Drive. Once again, the link will be down below the lesson or within the video kit. So, just go ahead and download it. Once you do that, unzip it. And you'll see that in there you have a couple of different folders. Just take this public folder and drag


00:53:40
and drop it right within your source folder. Once you do that, you'll be able to see the different fonts that we're using as well as some images that we'll use later on within our application. So, if you head back over to the navbar, right within our p tag where we have our text, we can also render an img with a source of forward/ images forward slash logo.png and we can render an al tag of logo. If you do that, you'll notice that you can't access your logo just yet. That's


00:54:12
because in V applications, the public folder should be within the root of the application, not within the source folder. So just delete the default one that is already over there and then move this new one into the root of your application. As soon as you do that, you'll see an error. So head over into your app terminal, stop it from running, and then rerun it again by running mpm rundev. As soon as you do that, your assets will be taken into account. And now you should be able to see a little


00:54:38
logo right here on the top right and not just a broken image. Also, you can head over into your index html and instead of saying v SVG, you can say images logo.png so that your favicon gets updated as well. And there you have it. This is our navbar. If you expand it, you can see that it looks great on desktop devices as well. But now what we have to do is that when you scroll, we actually want to apply this glassy background so that when the text goes over some other text, it is still fully visible and not


00:55:14
interrupting our viewing experience. Of course, we won't be able to test it just yet because we cannot scroll as there's no other content, but I can show you how we can implement it. And this is actually going to be the first time we're going to use Gap in this application. Right at the top of our component, I'll say use GSAP. And you can import this from add GSAP react. This is a helper hook that allows us to very easily use gap within our application. You can define a callback


00:55:43
function right within it. And then you can define a timeline by saying const nav tween. Now why did I call it a tween? Well, tweening in animation is short for inbetweening, and it's the process of generating images that go between different key frames. That's a very technical explanation, but it'll start making more sense as we start implementing it. And of course, if you want to truly understand how it works behind the scenes, then go ahead and check out our Gap course link down below. But for now, I'll also get access


00:56:14
to the original GSAP library by importing GSAP from Gap and then I'll say timeline. So, we're starting to build a GSAP timeline that will be based off of a scroll trigger. And the trigger will be the nav. Specifically, we'll start it from the bottom to the top. What is this means? Well, these two properties control when the scroll animation starts and ends. And the first part is referring to the elements position. So, the position of the nav. And the second one is referring to the viewport position. In this case, when


00:56:51
the bottom of the navbar reaches the top of the viewport, that's when we actually start applying a specific class. So now that we know when the animation will start applying, we can say what will happen. So I will say nav tween dot from two. And this from to is a method that ensures that the nav always starts from a known style which is going to be transparent and it ends with a specific effect. So the first parameter is the target that we want to animate. Then we have the duration. Then we have the from


00:57:28
variables, the two variables and the position. So I'll say nav. Then I'll say that we start with a background color set to transparent. And then I will say how it will end. We want to end it with a background color of hash 000000 which is black. But I'll also end it with 50 which in hexadimal is 30%. So it'll have the opacity of 30%. I'll also give it a background filter which will be set to blur 10 pixels. And finally, I'll give it a duration of 1 second. And you can also choose the ease, which I'll


00:58:13
set to power one dot in out, which is how that animation will actually play out. This will create a smooth animation. Now, it looks like I didn't properly close this background color. But as soon as I do that, you can see that it's no longer complaining. And now it's pretty clear what's happening. So later on once we add additional sections and when we allow the user to scroll down as the bottom of the navbar reaches the top of the viewport that's when it'll actually turn from a transparent


00:58:41
background to a dark blurry background that allow us to read the text even though it's showing on top of the other elements. Great. So, now that we have the navbar, let's move over to the most important part of this course, and most likely the reason why you clicked on this course in the first place, and that is the hero section with this sick animation where the ice cube falls into the cocktail and animates as we continue down the screen. Let's get started focusing on the most important section of this course, this


00:59:14
animated hero section. First, we'll start just on the layout and the structure and then later on we'll animate it using GAP to create this smooth and interactive experience. So, back within our code, create a new component and call it hero.jsx. run rafce right within it and then just import that hero section right within our app below the navbar by saying hero and autoimp importing it right here. Webtorm does that nicely automatically for me. Now let's develop the structure of the hero section by wrapping it in an


00:59:52
empty react fragment and then within it creating a new section with an ID equal to hero so we can scroll to it and a class name equal to noisy. As you can immediately see this noisy class name adds a background image that makes it seem a bit old school. So if you want to see how this noisy exactly works, head over into our index.css CSS and you can see that it is just applying a full-size noise background image. Within it, we can render an H1 that will have a class name equal to title and it can be the


01:00:28
name of a cocktail of your bar or whatever you want it to be. I'll go with something like mojito. Sounds interesting and looks good. Then right below it, I'll render an image with a source of forward slashim images slash her leftleaf.png with an al tag of left leaf and a class name equal to left leaf as well. Now you can see that leaf right here at the bottom on mobile devices. I want to duplicate this image right below. And what I'll do is just rename all of the keywords to right instead of


01:01:11
left. So hero right leaf, the al tag, and the class name of right leaf as well. If you do that, you'll see another leaf appear right here. Next, below these images, let's render a div that'll have a class name equal to body. And within it, another div with a class name equal to content because we're going to put the majority of our content within this div. So, let's create another div that'll help us with the layout. So we can give it a class name of space-y-5 to create some spacing in between the


01:01:52
elements. It'll be hidden on small devices, but it'll be showing on medium and larger devices. So we can set it to block. Within it, I'll render a P tag of cool, crisp, and just classic. and another P tag below it with a class name equal to subtitle that'll render a text of sip the spirit with a break of summer. Yep, that definitely sounds good. Now, we cannot see it on a mobile device, but if we expand it just a tiny bit, you can now see cool, crisp classic s the spirit of summer. And on larger devices, it'll


01:02:37
actually get moved to the bottom left. So, we have enough space to show our primary part of the page. Great. So, now let's head below this div that has the space of Y5. And let's render another div that'll have a class name equal to view cocktails and a p tag right within it that'll have a class name of subtitle. And here we can put some text. Now I don't want to just imagine some text or generate it using AI. So I'll head over into my Figma design and just copy this piece of text that I can see


01:03:16
right here. Every cocktail on our menu is a blend of premium ingredients, creative flare, and timeless recipes designed to delight your senses. This wasn't written by Chad GPT. Not at all. And below this P tag, we can render an anchor tag that'll have an href pointing to hash cocktails and it can say view cocktails. So now if we go back you can see that we have both the left and the right side and this will eventually lead to the bottom page but we have still left some space for the primary part


01:03:51
which is that drink. Now before we show something right here let's first focus on the animations. See if I head over to the final website you can see that first of all the primary text animates then we see the text at the bottom left and finally then the text at the bottom right. So, let's animate it. Right at the top of the hero section, we can use the use gap hook. Make sure to import it from gap react. Create a callback function. And as the second parameter, give it an empty array, which means that this will only


01:04:27
have to run at the start. Next, we can define a couple of different animations. First, I'll define one called hero split where we can use the split text gap plugin that'll break our text into smaller pieces so we can animate them individually. So, I'll make it equal to new split text which we have to import. So, I'll say import split text coming from GAP all. And don't forget to import the GSAP itself by saying import GAP from GSAP. Perfect. Then I'll say that we want to


01:05:05
target the title class name and we want to split it into both characters and words. So I'll say type will be chars characters and words. Now we can do the same for the paragraphs. So I will duplicate this. I will say paragraphs or paragraph split and make it equal to new split text where we're going to split the subtitle class name into just lines. Not characters, not words, but lines. What does this mean? Well, if you take a look at the finished website, notice how we split the first one by each letter.


01:05:46
And the other ones are split line by line. So we don't animate the characters themselves but only line one, line two, three, four and so on. Perfect. Now that we have split those characters of the hero section, we can actually apply some animations. So I will say herplit.chars or characters do for each character we want to apply a class name by saying char.class list.add add and I'll apply a class of text gradient. This text gradient is a utility class within index.css which adds a bit of a


01:06:30
dark gray color to the text. It'll be applied before animating. So if I reload, you should be able to see that now the letters seem to be a bit more 3D as they have a gradient very slight one from the bottom to the top. Now let's use gap to animate each one of these characters by saying gap from herplit.jars. And we want to first set where they're coming from. So they're starting from y% of 100. They're starting from a duration of 1.8 with an ease of expo. Expo out gives a smooth springy feel. And finally, a


01:07:13
stagger of 0.006, which means that each character will come in after another, creating a wave effect after 0.06 seconds. So now if I reload, you can see how already the letters start coming from down below and move up and they align very nicely. You can totally slow this down by staggering them by 1 second, for example. And now you can see exactly what is happening. Although, please, I beg you, never do this in real production websites. Even though it might be cool, you want your websites to feel fast. And if you have


01:07:51
long animations, they're just not going to feel fast. So, I found 0.00.6 or five to work very nicely just so it's visually interesting, but it doesn't negatively impact the user experience. Next, let's animate the lines of text of these paragraphs. So I'll say gap dot from paragraphsplit.lines. We want to animated from opacity of zero initially y% of 100 duration of 1.8 ease of expo.out stagger of also 0.06 and a delay of one. What this delay does, and it's super important, is that


01:08:39
it means that it'll start one second after the headline animation finishes. So now if I reload, you can see that these lines will start animating only a second after this finishes. If you remove the delay, then everything will happen at the same time, which is just too much to see. So we want to delay it purposefully so we have this nice animation. Great. Next, we want to animate the two leaves in the hero section when the user scrolls. But for the animation to trigger, the page needs some scrollable content. So, head back


01:09:16
over into the app.jsx. And let's just add a temporary div with the full height just below the hero section, which will allow us to test the scroll-based animations. So I'll say div with a class name equal to h dvh which is a full height and a bg of black. So now you can see that we can scroll into nothingness. This allows us to test the navbar effects that we have but it'll also allow us to test the scroll on the leaves. So now we can go back to the hero section and below the animations of the text we can add the


01:09:57
animation for the leaves by saying gap timeline. This one will be based on the scroll trigger and we have to watch the trigger on the hero section. So once we reach it, we will start when the top of the homepage hits the top of the screen and we will end when the bottom of the homepage hits the top of the screen. And we can also add a scrub to this which means that the animation progress will be directly related to the scroll which will make it feel natural. So what animation do we actually want to give to


01:10:32
it? Well, we can say dot2 dot right leaf. We'll give it a y of 200 and zero. And then I'll apply another dot2 this time to the left leaf. I'll give it a y of minus 200 and zero as the second parameter. Now, if you save it and reload, as you scroll down, you'll notice that the top leaf moves up as we scroll and the right leaf moves down as we scroll, creating this very interesting effect. Pretty cool, right? Almost feels like we're in a jungle. So, what we have done so far is animated the


01:11:18
title as well as the paragraphs below. We animated the characters and added staggered motion. And then we used the scroll trigger to animate the movement of these leaves based on the scroll. These kinds of animations add polish and elevate the user experience, especially on hero sections where the first impressions matter the most. So I'll go ahead and commit this right now by saying get add dot getit commit-m implement the first part of the hero section and get push so that our members on jsmastery.com can follow along without


01:11:59
any issues. With that in mind, in the next lesson, let's focus on what matters and that is animating the actual video on scroll. Let's focus on the most important part of this course and that is adding the drink animation effect which is actually just a video that is playing frame by frame as the user scrolls through the page. So, in this lesson, I will demystify these complex animations and show you that oftentimes they're basically just very smart ways of using videos or images. And then the final


01:12:37
effect ends up looking something like this. So, let's go ahead and make it happen. Back within our hero page, we want to render a full screen video. It'll be muted and in line so it behaves well on all browsers and devices. So, I'll head below the section that has a class name of noisy. That is this one right here. If I click it, notice how WebStorm automatically selects it right here at the bottom. And then just below it, I'll render a div that'll have a class name equal to video absolute,


01:13:14
which means that we don't want it to interact with other elements on the screen, and an inset of zero. Now this video class name if you search for it you'll see that we have actually declared it within our index.css where we apply a full width. We change the height on medium devices and we just apply some additional properties such as object bottom and object cover in order to render that video. Well, next, right within this div, I'll render the self-closing video element with a source


01:13:46
equal to slash videos/input.mpp4. Why input mp4? Well, because if you head over to public videos, you'll see that this is the video that we have. I'll also make it muted so we don't play any sound. You rarely want to play sounds in your web applications. Sometimes there's good opportunities to do that, but in most cases just leave them on mute. I'll also say plays in line so we don't actually show an additional uh video like element uh like the track bar where you can move through the video or


01:14:21
increase or decrease the volume. We want to hide all of that. And I'll say preload to auto because we want it to load automatically as the user opens up the page. And of course, we want to be able to work with this video. we want to do something to it. So we have to attach a reference to it which I'll call a video ref. Then right at the top of our hero page I'll say const video ref is equal to use ref coming from react. And while we're here I also want to figure out if we're on a mobile device. So say


01:14:58
const is mobile and I'll make that equal to use media query which is this react responsive package we installed before and I want to give it a max width of about let's do 767 pixels. So if it's up to that then it's going to be mobile else it's going to be web. Now we can head below the use gub hook that we have already created specifically below the gub timeline where we have animated the right and left leaves and we want to figure out where the animation will start and end.


01:15:36
So for example we can say something like const start value and then we can say that it'll start at center 60%. And we can also say the end value will be equal to something like bottom top. Now these values will be different for mobile devices because there is less space. So right here before assigning value I'll first check whether is mobile is true and if it is I'll give it a different value such as top 50. And same thing for the other one. I will say if is mobile in that case I'll say 120% and


01:16:17
then top right here for the second property. So what do these values mean? Well top 50 means that when the top of the video always remember that right the first property is referring to the element we're animating. So when the top of the video reaches and then this is talking about the screen. Okay. So when the top of the video reaches 50% down the screen, the animation starts. Similarly, when the center of the video reaches 60% down the screen, the animation starts. That is on desktop. In this case, we have the percentage at the


01:16:53
start. So this means that when the top of the video goes 120% past the top of the screen, meaning far off the screen, we end the animation. And bottom top means that when the bottom of the video reaches the top of the screen, then the animation ends. We dive much deeper into these values within our GSAP course. But I think this is going to be good enough for now. And now that we know the start and the end values, we want to animate the video. You know how at the start I mentioned Juny, which is the smart


01:17:23
coding agent that makes you a more efficient developer? Well, I want to put it to the test right now so you can download it and follow along with me. The link is down in the description. I'll press command shiftp and then search for Juny, which will open it right here on the right side. And remember how at the start of the video I said that it's going to be very hard for AI to replicate some of these beautiful animations. Well, that is entirely true if you don't know how to approach them.


01:17:50
But as I said, this entire animation is nothing more than animating a video on mouse scroll. So if you know that then you know that it's not some kind of magic. You have demystified it and therefore you're able to turn it into something that you can easily develop. And if you know how to approach it then AI can also do it for you. So let's try to write a task for Juny to do it for us. I'll say create a GSAP timeline that animates the video as the user scrolls through the page. And I think this is


01:18:26
good. I mean, this is a very limited prompt. It contains half a sentence, but let's see what Juny can do with that limited info. It'll say sending LLM request. So, first it created a plan, and I want to go over that plan with you. It says check if scroll trigger is properly imported. Create a gap timeline that animates the video based on scroll. Use the video ref. Use the start and end values. Add appropriate animation properties. Ensure that the animation works on both mobile and desktop. add a


01:18:57
check and it's doing all of that in real time. As you can see right here, it's actually animating things and testing whether it works. So, we can see the changes right here in real time. The animation code has been updated to use a new video timeline reference, ensuring proper handling of video loading and playback. The video now plays when in view, and the animation is updated based on the duration. Successfully updated, ready to play whenever the user scrolls. And that's it. A GUP timeline has been


01:19:28
successfully created to animate a video as the user scrolls through the page. Utilizing the video ref for targeting and responsive behavior with the start value and end value. The implementation is error-free and all tests pass ensuring a seamless video experience. Well, we'll see about that. But the actual code is here. So now let's see whether it works. If I head back and reload, you can see that the animation starts automatically. It actually slows down a bit. And that's it. and then it


01:19:55
replays. Also, if I scroll down, you can also notice how the glass is getting smaller. And it's actually working incredibly well. But it looks like it wasn't precise enough. We wanted a parallax effect where we control the entire video flow. I'm going to teach you how we can do that. But hey, this might even be better. This doesn't require a user to scroll. Rather, they can just take a look at this amazing animation right here. Still, we want to tweak it just a tiny bit and allow this


01:20:23
glass to flow onto the second section and then end the animation there solely based on scroll, not on autoplay. So, Juny did an amazing job right here. But now, from scratch, we'll go over it together and I'll show you how we can make this animation work for our specific use case. In this case, we won't be triggering the hero section. Rather, we'll be triggering the video. The start and end values are corresponding to the start and end values we have created right here. And then scrub is turned on, which means


01:20:53
that it'll make the video play on scroll. We also want to allow something called a pin to be set to true. This will keep the video stuck on the screen while you scroll. So as you scroll, the video doesn't move. It'll stay in place. Next, instead of using these methods directly on the timeline or calling the dot from two, I will just remove all of these and also remove this update animation when the video metadata is loaded. Instead, I'll just say ref.curren.onloaded metadata. I'll create a callback


01:21:29
function and I'll have to properly end this part right here. And within it, I'll say video timeline referee ref.curren. And we want to change the current time of the video to be equal to video ref.curren. duration. So this way we're updating the current time based on the video duration. And alongside this, I also want to head over to the video and turn off the autoplay that we had here. We also don't need the loop because we're going to move it with the animation up and down. So now if you head back over


01:22:06
to your app, it won't play by default. But as you start scrolling, you'll notice that the glass moves down. But wait, this is looking worse than what Juny did initially. Oh, I think I know why that is. Here we have to actually create a new variable for the timeline, not refer to the timeline ref. So I'll say const TL as in timeline. And then we'll use that TL right here when you say video timeline ref just TL.2. This will actually tie the current time with the duration. So if you get back right


01:22:37
now and reload the page and start scrolling, you'll see that the animation is being applied on scroll. Perfect. Now, if we compare this with what Juny initially did, well, to be honest, I cannot really tell which one is better. This one actually plays it both on scroll, but then it also continues the animation later on. So once we actually finalize the second section, I think Juny's might actually be better. So Juny has passed the taste. But just to stick with our design, I'm going to bring us


01:23:07
back to our final solution. Now you can notice that on my end the animation feels very smooth. On your end, it might feel a bit choppy. Something like this. And if you use your mouse to scroll, then it depends on how your mouse wheel is actually sending the signals to your computer. If I use the touch bar on my MacBook, it is very smooth. But with the mouse scroll, it is a bit less smooth. So that is the difference. But again, why should we make it feel like it skipping frames? This is actually


01:23:35
happening because most videos only have a key frame every few seconds. But for scrub-based animations, we need every single frame to be a key frame. And we can fix that using a free open-source command line tool for processing video and audio files called ffmpeg. So just head over to their website and download it. Once you download and install it, we just have to run one single command. And I'll actually link it somewhere below this lesson or within the video kit. So you can just copy and paste it or feel


01:24:10
free to type it out by hand. And if you're new to this, don't worry. You don't have to learn this at all. We just need one single command. You don't have to know how to use this software. Now, first of all, you'll have to run this command within where our video is contained. So, we'll have to cd into public and then once again cd into videos. Once you're there, you can copy it and run it. In my case, it says that the output file already exists and asks me do I want to override. I'll say no.


01:24:39
And you can say the same thing. That's because I already provided this new output file for you which has a one frame attached to every single key frame. So it makes the animation smoother. So now we can head back over to our hero page. Scroll down to where we have the video. And instead of displaying video's input, I'll display the output.mpp4. So if you reload and try to test it, it'll be a bit smoother even with your mouse. But if you have a touch bar or on phones, it'll feel even smoother, which


01:25:13
means that the video is now fully optimized for the scroll trigger playback. Now, why are we scrolling this glass into an abyss of nothingness? That's not what we want our user to see. Instead, we want to scroll it into the pricing of other cocktails that we offer, which is this section right here. So, let's head back over into our homepage, that is our app right here, and delete this div, which for now just helped us to scroll. But now, in the next lesson, I'll show you how we can add the cocktail section. So, just


01:25:45
remove this div. Let's also commit it to GitHub. First, you'll have to cd two times to get back to where our project is. Then type get add dot to stage all the changes and get commit-m implement hero scroll animation and then get push to push it over to GitHub to get started with our cocktail section. Let's head over into our components folder and create a new file called cocktails.jsx. run rafce to quickly spin it up and then let's import it right below our hero within our app.jsx.


01:26:27
So that is cocktails. Perfect. This is how our current animation looks like on mobile. We'll definitely improve it as we go, especially this extra light scroll bar which we don't really need right here at the top. But for now, let's focus on the cocktail section. So just scroll down, head over into it, and let's start implementing it by turning this div into a section and giving it an ID that we can scroll to. So we'll say cocktails and a class name of noisy as well because we want to match it with the top


01:26:59
section. Next, right within it, let's also render an image with a source equal to slash images slashcocktail left.png with an al tag of left leaf and an ID of C as in cocktails left leaf. That'll look something like this. Then just below it, I want to duplicate it and create one for the right leaf. I'll call it R leaf and C right leaf. As you do that, you won't see any changes. There's still going to be only the two leaves that we implemented before, but none on the cocktail section. That's because we


01:27:45
haven't yet properly animated them and put them where they need to be on the screen. But for now, let's focus on the list of the cocktails. So, I'll head below this image and render a div with a class name equal to list. And within it, I'll render another div with a class name equal to popular. Within it, I'll render an H2 that'll say most popular cocktails. And then below it, I'll render the UL where we can map over those cocktails. So within this UL, map over cocktail


01:28:20
lists do map. And this cocktail list is coming from our constants where we have all the most popular drinks. So I'll map over each drink and for each one I will automatically return an LI which is a list item with a key of drink.name and then within it I'll render a div with a class name on median devices margin e which is inline end of 28. When you want to position something in the ends of the screen, I found this property to position it very well. Then we want to render an H3 that will render the


01:28:59
dynamic drink name and a P tag which will render the drink country. So where is it from and drinkdetail? So some more details about the drink. Finally below the div, I'll render a span with a dash or a line and then I can render the price. I'm noticing that we're mentioning drink one too many times. So, we can just dstructure everything from the drink such as the name, country, detail, and price. And now you don't have to mention it multiple times. You can just say what you want to get from it. If you do that


01:29:39
and save, you'll see that now it looks something like this. For example, we have Chappelle Hill Shiraas, which is about 10 bucks. Not sure what this one is. Oh, it's a bottle. Okay. But even though it's a bottle, it's still very expensive. for that kind of money, maybe it would be better to just head over to jsmastery.com and get yourself a monthly subscription instead of spending money on cocktails. But hey, to each their own. And here I will end this div of popular. But what we can do now is just


01:30:05
duplicate this entire div. And for this one, I'll call it loved and I'll say most loved. Mocktails are like cocktails but without any alcohol in them. So basically like sodas. And I'll map over the mock tails list. I'll also extract all of the properties. And I'll always make it just me28. No need to do it only on medium devices. And now you're going to end up with something that looks like this. Now, of course, this looks so much better on larger devices. So, if I head over to tablet, you can see that now we


01:30:38
can actually see the menus appearing on top left and top right of the end of the animation. And the leaves are right here at the bottom left and bottom right. But they're not being rendered properly. That's because I misspelled the cocktail right here. So if I spell it properly, you should be able to see two huge leaves appear at the bottom left and bottom right. But as we applied a little animation to those two, so that they appear like a parallax moving up and down, we can also apply a little


01:31:06
animation to those two at the bottom. So let's actually do that to recap our understanding of GAP. See in React or Nex.js applications, you can use Gap through the helper libraries. For example, a library that exposes a use gap hook called at Gap React. Still, you also need to import the original GSA library from Gap, but the Gab hook makes it easier to use. So you just say use Gap. You declare a callback function and you close it right here. Within it, you can start defining your timeline which


01:31:44
you can then move up and down. So say const parallax timeline is equal to gap timeline where you can define the type of trigger for that application. In this case, I'll say it's a scroll trigger where we will trigger the cocktails section. So here we want to say that we want to start once the top of the section reaches about 30% of the viewport or of the screen. Similarly, we want to end the animation when the bottom of the cocktails screen or hash cocktails reaches about 80% down the screen. And


01:32:28
we can turn on the scrub to be true, which means that we want to animate it on scroll. The timeline just defines when the animation will happen. But we haven't yet said what will happen with those leaves. And by the way, if you're wondering how I came up with 30 or 80 or top or bottom, it was just a bit of trial and error. You have to play around with it and see what works. So now that we have this timeline, I'll say parallax timeline from. So we move it from what specific class name from C left leaf.


01:33:01
And we want to give it X is min - 100 and Y is 100. So we move it to the left on the X-axis and 100 pixels up on the Y- axis. And we also want to apply another dot from this time for the C right leaf and X is going to be 100 and Y will be 100. So they're going to move in the opposite directions. Basically we're targeting those IDs that we have given them right here. So now if you scroll down and if you scroll very slowly, notice how this one on the left comes up first and then the one on the


01:33:38
right also comes up. So it's like you're moving your cocktail into a jungle. And that's it for this parallax scroll on the leaves. These subtle movements like this make the page feel more alive without it being too distracting. So let's check it out one more time on desktop. We can see all of the nice animations, particularly the one where we animate each letter of the word mojito. And then as we scroll down, the ice falls into the glass and we can see more cocktails that we can order. And


01:34:08
then the bottom leaves appear greeting us into the jungle. So amazing job on finalizing two super exciting sections of the cocktails website. Let's not forget to commit it. So I'll head over here and say get add dot get commit-m implement cocktails section and push it. And if you want to quickly deploy it, head over to verscell.com and add a new project. You'll see that Gab Cocktails has had some changes. So you can just click import. It'll automatically recognize that it is a new


01:34:46
V project or whatever other framework or library you used. You can also choose your project name right here. And you can just click deploy. Now it'll take a couple of minutes for the project to be deployed. And then you'll be able to check it on the internet and share it with your friends or put it on your portfolio. Check out these animations on top. You were able to see some light if you were fast enough to spot it. And it looks like our project got successfully deployed. So click on it right here. In


01:35:16
my case, it's live on this URL. For you, it's going to be something different. But what matters most is that now we can copy that URL and share it with your friends and potential employers or just put it in your portfolio. Okay, so now that we're here, let's see if it still works exactly like it did locally. If I scroll down, the ice still falls into the glass and we can see the prices and we are in the jungle. This works great. On mobile, it looks like this. The text is still fully readable. You can quickly


01:35:46
scroll to it by clicking here. And we do have some extra space right here. But as soon as you start scrolling, that space is filled with these leaves. And then we can see the cocktails. Of course, applying GSEP animations to screens of different sizes such as mobile or tablets is a whole other game because we have to know exactly how to apply a specific animation so that it works on that specific device. And of course, that's covered in a lot of depth within the ultimate GSAP course. Let's get started working on the about


01:36:20
section of our cocktails page. In this one, we'll have a little title right here saying that we pay attention to every detail and then say a bit more about how we serve our cocktails and who do we serve them to as well as show some nice graphics of people having fun in our bar. And of course, this will come with a great animation. So, first the title will animate and then after the title, we'll get all of the images one after another. So we can get started working on it by creating a new


01:36:50
component within the components folder which I'll call about.jsx and I'll runce to quickly spin it up. We can immediately import that right within our app below the cocktails. So I'll say about and end it right here. And as soon as you do that, we now have this new section right here below the drink. So let's develop its UI by giving this div an id of about. So we can scroll to it. And within it we can create a new div with a class name equal to margin bottom of 16. On medium devices padding x of0


01:37:28
and usually padding x of 5. Then we can render another div right within it with a class name equal to content. And then within the content we can render another div with a class name equal to on medium devices call span of 8. So we can prepare some space for this heading text that will show right here. And then we can render a p tag that'll have a class name equal to badge and it'll say best cocktails. And below it, we'll render an H2 that'll say where every detail matters. And then we can also render a


01:38:10
span element that'll just render one dash with a class name of text-white. Then let's actually space this out nicely. So after the dash, still within the h2, we can say from muddle to garnish, which is just some cocktail jargon saying that we'll prepare everything. Now we can go below this div and we can create one more div just below it with a class name equal to sub content. But I can already see that something is wrong here and that is that our cocktail drink video is actually moving down. Oh no, never mind. Now it's


01:38:46
good. So let me just reload. And as I scroll now, it should kind of get stuck right here. And then we should have a clean section which allows us to focus on the subcontent. So within it I'll create a P tag and here we want to display some text. Now the simplest way for me to get that text is right here from the design. So I will copy this part where we say that every cocktail we serve is a reflection of our obsession with detail. Then right below this P tag, we can render a div. And within


01:39:16
that div, we'll have another P tag with a class name equal to on medium devices, text-3 XL to make it very large text- Excel typically and font-bold. Within it, I'll display a span element of 4.5 and then outside of it out of five. And then below this P tag, I'll render another smaller text. So I'll give it a class name equal to text-sm text-white 100. And if we have done that properly, we can enter a piece of text that says more than and then we can type a specific number of customers. Perfect.


01:39:57
Now on our current website, you should be able to see something that looks like this. But of course, let's focus on the grid where we can display additional images. So I'll head below a couple of divs. actually 1 2 3 4. So we're going to exit this subcontent right here. And then here we want to display another div that'll have a class name equal to top grid. Within it, I'll display a div with a class name equal to on medium devices call span 3 with a div that'll have a class name of noisy and it'll be


01:40:41
self-closing. And then we can render an image that'll have a source of images abt. So that's the about section.png, PNG, but make sure to say abt1 because we'll have multiple with an al tag of grid img1. Now, if you save this, you should be able to see this little image. And if you remove the noisy class, it'll be in full clarity, but we do want to have this special bar type feel. Now, we can duplicate this div a couple of times. So, I'll take this div, duplicate it once and one more time, and I'll space


01:41:20
them all out nicely within this parent div that we have, the top grid. In the second one, I want to say call span six. So, it'll be taking more space and I'll render the about image two. And then for the third one, I'll say call span three, about image five. And save it. And now we can see three of these different images. Now I'll create another div that'll have a class name equal to bottom grid. And within it I'll duplicate one of these divs that has the div and the image inside of it. And I'll


01:41:57
say call span 8. So this one will be long. It'll render the about image three. And just below it I'll duplicate it once again. And I'll render another call span 4 with the about image four. Why do we have 8 and 4? That's because the full width is 12. So in this case, we have 3 63 which is 12. And here we have 8 and 4. And if we save this on mobile, we show all of them one after another. But desktop is where this truly shines. So as we scroll down here, you can see this new layout grid that we


01:42:35
created. But now is the time to animate it so that everything fades in naturally when the user scrolls in view. And at this point, you should already have a pretty good idea of how we can make it happen. Right at the top of this component, I'll use the use gap hook by saying use gap coming from gap react. And I will just open up a new callback function within it. Then we can start defining our different animations and timelines. First I want to split the title into words. So I'll say const


01:43:05
title split is equal to split text dotcreate and we want to call it about h2. So basically here we're targeting the h2 element inside the about div and we want to split it by the type of words. Now, don't forget to import GSAP coming from GAP as well as import in curly braces split text coming from GAP all. We also need to create a timeline that allow us to choose when we start with the animation. So, I'll say const scroll timeline is equal to gap.timeline. It'll be a scroll trigger animation and


01:43:48
the trigger will be attached to the about element. So to the entire section and we'll start it when the top of the about section reaches the center of the screen. And now we can start animating it by saying scroll timeline dot from title split dot words. And we want to give to it some initial styles such as it'll start from the opacity of zero. It'll last for 1 second. It'll start from the top. So y% will be 100. We can choose the easing of the animation. So we'll use the expo out. And we can


01:44:23
choose the stagger between each different words of 0.02. So that the animation is pretty fast. To this I'll also attach another dot from. This one will be concerning the top grid div as well as a bottom grid div. So we're targeting both the top and bottom row separately. To both of them I'll give the opacity of zero, duration of one, ease of power one and out and a stagger of 0.04. I found this value to work the best. And then you can also apply a second parameter to this from which is a string of minus


01:45:08
equal to 0.5. What this will do is it'll make the animation start half a second before the previous one ends. So both animations will overlap a bit which feels smoother and faster. So now if we save it and if you reload notice how each word falls into place one after another very quickly and then immediately while that is happening we can also see the top and the bottom row kind of start coming up together. It is very subtle, very quick, and seamless. No flashy animations. And at this point, I think you have a pretty


01:45:46
good idea of how we're applying all of these animations. So with that in mind, let's not forget to commit it by saying get add dot getit commit-m implement the about section and get push to push it over to GitHub so that in the next section we can focus on this amazing pretty different art section. This is going to be all about how we're creating those cocktails and we'll actually lead the user through the story of the creation through an image overlay. So, as they scroll, they'll be able to see


01:46:22
the full story. More on that in the next lesson. Let's dive into the art section of this course. It's pretty exciting to be honest because it's one of the sections that is different from the other ones. To this one, we just applied a timeline and show the elements one after another in a specific time frame. But for this one, we'll actually unlock the entire section that is behind it using something known as a mask. So, if you check out the final version, it'll look something like this. We go to the


01:46:53
section that we have developed just before. And then as you start scrolling, you can see the art section and you think that's it, right? But then as you continue scrolling down, you'll notice that a mask of this image appears. And it seems like you're entering into the world of this barman creating the cocktail just for you. So let's build it. I'll create a new component right within the components folder and I'll call it art.jsx. Within there, you know the drill. I'll


01:47:23
runce to quickly spin it up and then I'll import it over within our app. That's going to be art just like this. And then we can enter into it and start creating it. So first things first, we have to give this div an ID equal to art. So we can scroll through this section later on through our navbar. And then within it, let's render a div with a class name equal to container, margin x of auto, so we center it horizontally, height of full, and a padding top of 20. Within it, we can display an h2 that'll


01:48:02
say the art. And we can give it a class name equal to will fade. Now if we reload our application and scroll down, you can see just the art headline right in the middle. But now below it, let's render some more content. So I'll render a div that has a class name equal to content. And within it, it'll have a ul, an unordered list with a class name equal to space-y-4 to create some spacing and will fade as well. And within it, we can map over good lists.m map where we get different kinds of features as well as the index


01:48:46
for each one of these features. Let me show you what those are. These are coming from our constants. And we're talking about a list of some features that we offer. For example, handpicked ingredients, signature techniques, bartending artistry, and freshly modeled flavors. So for each one of these, we'll render an LI, a list item that has a key equal to the index, as well as a class name equal to flex items-c center and a gap of two. And for each one of these, we'll render an image that'll have a


01:49:20
source of images check.png with an al tag of check. And then we can render a p tag that'll render the actual feature. So now we can see those four right here in the middle of the screen. But now let's render the main star of the show which is the cocktail image. So I'll head below this ul still within the content part and I'll render another div that'll have a class name equal to cocktail dash img and within it I'll display an image that'll have a source of forward slash images


01:49:59
slashunder img.jpeg JPEG an all tag of cocktail and a class name of ABS center. So absolute center masked img size dash full and object- contain. So if we save it, you can see this little image appear right here. But actually what's happening if you take a look at the masked image class name that we're applying to it, you'll see that this is actually taking that image and then positioning it nicely in the center and applying a mask. So basically we're applying a mask image and let me show


01:50:38
you how that one looks like. It is within public images and then we can search for mask image and you can see that it is just a single regular drink. But then we also have the regular image, the one that we used, which is the under image. So let me show you how the under image looks like. It's this one, the whole image. But did you know that natively in CSS, you can take one image and then choose another image such as this one to be the mask. And if you do that properly, if you say mask image, then it'll take the shape of


01:51:13
that other image. Pretty cool, right? Now we can head below this div and create another ul. This one will actually be exactly the same as this ul. So I'll just copy it and paste it right here. Space y4, but instead of good lists, we'll map over the feature list. Map over it. Give it item center, but I'll also give it justify start and a gap of two. And to this P tag, I'll also give a class name equal to on medium devices W fit and typically W60. So now on mobile, they look exactly the


01:51:51
same, but if you expand it, you'll be able to see it on the right side. And now let's also render the text below it. So I'll head below this UL and below one more div. And I'll render a div with a class name equal to masked content or container with an H2 that has a class name equal to will fade. We'll target these later on using GAP to fade them. And I'll say SIP worthy perfection. Below this H2, I'll render a div that'll have an ID equal to masked content. Beneath it, I'll render an H3. And here,


01:52:33
we can just copy from the design made with craft poured with passion. So, I'll just paste that in this H3 right here. And I also want to copy this text right here for the P tag, right below the H3. This isn't just a drink. It's a carefully crafted moment made just for you. So, you're turning everything into an experience. So now if you head back, I mean you can see this, but you cannot see the H3 and the P tag because they have an ID of mass content. So we'll only show them as the user


01:53:06
scrolls through the site. So now let's bring this entire section to life. As the user scrolls, we'll pin the section, fade out the initial content, scale and reveal the image mask, and finally fade in the closing message at the bottom. All of this will be linked only to one thing, and that is the scroll of your mouse wheel. So, let's animate it right here at the top of this section by first figuring out if we're on mobile or not. because based on our width, we might need to position our


01:53:40
elements a bit differently. For that, I'll use the use media query and set the max width to about 767 pixels, same as before. If it's below that, we're going to consider it a mobile device. Then we can use the use GAB hook and right within it, we can define the start value of our animation. So I'll say start is equal to if we're in mobile we're going to start it when the top of the component reaches the 20% of the viewport else we're going to start it on top top so as soon as we reach it once


01:54:20
again this required for me to play with it a bit to figure out the best values so now that I know we can just type them here and now we want to focus on the timeline itself so I'll say const mask timeline is equal to gap which we have to import at the top. So right here say import gap from gap and then you can say gap.timeline and we can craft a new timeline based on the scroll trigger where we will trigger the entire art section. We'll start the animation once we reach the start point that we declared above and we'll end it


01:55:02
once the bottom of the section reaches the center of the screen. I'll apply a scrub animation right here. And I'll set the scrub to 1.5, which will be smooth scroll control, which means that the animation progress will follow the scroll but with some delay. And I'll also say pin and set it to true. This will keep the art section fixed in place while scrolling through the animation. That is very very important. So just say pin right here. So now that we have defined the timeline, we actually have


01:55:36
to declare the animations. So still within the use gub hook, I'll say mask timeline dot2 dot will fade and we want to change them to opacity of zero stagger in between the elements of 0.2. two and we can use an ease of power one inout. This is one of the most commonly used ones. So this is for the will fade elements. So if I head back and reload as we scroll you can see that all the elements will fade. And then as you scroll up they'll reappear. So now that we have this two for the fading elements, we can also


01:56:16
apply a dot two for the masked image where we'll change the scale to 1.3 to make it bigger. I'll change the mask position to be center. I'll give it a mask size of 400% to make it bigger. duration of 1 second and I'll leave the same ease of power one dot in out. So now if I save this and reload and scroll down, you can now see that the mask actually widens throughout the duration of 1 second and shows our barman. And finally, we'll also want to show the mask content. So I'll say two


01:57:01
dot hash masked content that'll have the opacity of one, duration of one, and an ease of power one and out. So now as you continue scrolling to the end, you'll be able to see this new H2 and a P tag appear at the bottom, finalizing the section. Pretty cool, right? And this opens up so many possibilities of having one image being hidden behind the mask of another and then it expands and it invites the user in. This is such a powerful and effective section. And in mobile it'll look something like this


01:57:37
where it still makes a lot of sense. Sure, we could go ahead and reposition some elements to appear a bit better, but even this right here is pretty amazing. So let's go ahead and commit it by saying get add dot getit commit-m implement the art section and then get push allowing us to focus on our menu section next but so far great job on implementing this masked scroll. This has been great and I'm super excited to finish it off with this one. Let's get started with our menu section


01:58:15
where in the middle of the screen we'll have a drink that we show so that people get a visual representation of what they want to order. And also, let's be honest, these drinks are looking pretty cool. So once they see it, they're more likely to order it. Then we mention the title of this recipe as well as some more info about it. And we have left and right arrows that allow us to animate this drink in place. Let me show you what I mean. On the finished website, you can now click to swap between these


01:58:44
different drinks, see more information about them, and you can also use the right and left arrows to move between different drinks. And you can see how it nicely animates or slides in from left to right. So, back within the code, let's create a new component within the components folder, and let's call it menu.jsx, JSX where you can run rafce to quickly spin it up. Then as usual, let's just import it within our app file where I'll simply say menu and make sure that it comes from components menu. Then we


01:59:21
can head over into the menu and we can turn it into a section with an ID of menu so we can scroll to it from the navbar. I'll also add an area label by and set it to menu heading so that the users know that they can swap between different sections within this menu. Once again, I'll display some leaves. So, I will have an image with a source of forward slash images/lider leftleaf.png with an al tag of left leaf as well as an ID of M as in menu left. And I'll duplicate it below and change all the


02:00:02
dimensions of left to right. So I'll say right leaf, right leaf right here. And finally m right leaf. Perfect. And below those two leaves images, I'll display an H2 that'll have an ID of menu heading with a class name of SR only. What this will do is apply this class name where we are resetting the positioning of this heading so that we can play with the animations later on. And I'll simply make it say cocktail menu. Now, if we head back over to localhost 5173 and scroll down below the


02:00:44
art section, you can see that we have the left and top right leaves. And in the middle, we'll later on animate the title of the menu. But for now, we can focus on the menu itself. So below the H2, let's create a new nav element that'll have a class name equal to cocktail dash tabs with an area label of cocktail navigation. And within it, we can map over the cocktails saved in the constants folder. So if you head over into constants indexjs and you search for cocktails, I believe it's these four


02:01:21
which we can call slider lists or you can just rename it to something like all cocktails. Whatever you decide to use. Make sure to also change it right here at the bottom. So whether it's slider lists or all cocktails, whatever it is, just make sure to import it right here at the top from constants and then map over them by saying map where we have each individual cocktail as well as the index of that cocktail. And for each one, we can open up a new function block, not an immediate return, because first I want to figure out which


02:01:57
one is active. So I'll say const is active and it'll be active if the index corresponds to the current index of the cocktail that we're on. But where are we going to get the current index? Well, we can save it to the state. So right at the top, I'll say use state snippet and I'll call it current index and set current index at the start set to zero. Because we're in the first cocktail, we immediately have to turn this into a client rendered component. So I'll apply a use client directive at the top


02:02:30
because we're using a use state hook which is coming from React. And then based off of this active class, we can show some different information. So I will always return a button. And this button will have a key equal to cocktail do ID. It looks like I misspelled the cocktail right here. And it'll render the cocktail name. So, if we do this and scroll down, you can now see the names of four different cocktails that we're mapping over. But let's style it a bit differently so that we know which one is


02:03:07
currently active. So, I'll give this button a class name. And I'll make it dynamic where we will check whether is active is currently true. And if it is, I'll give it a text white and a border white. And if it's not true, I'll give it a text white over 50 and border white over 50. If you want to, you can also put this into multiple lines just so it's a bit easier to understand what's happening. Perfect. And now you can see that the classic mojito is currently turned on, whereas the other ones are


02:03:41
not actively selected. Now, we also have to give this button an on click element, which I'll do right here below the class name. And within it, we'll create a callback function that'll call the go to slide function to which we have to pass the index of the slide we want to go to. So we can also create this function right at the top. const go to slide. It'll accept the index. And we can then figure out which index we're trying to go to. So const new index is equal to. And now if we just let it to be index,


02:04:18
well in that case we would go from zero to one to two to three. And then we wouldn't have any more cocktails because that's it. We have four. And if the next time the user clicks four, well then it's going to lead them to the fourth, the fifth, sixth, and so on. But we don't have that many. So in this case, I'll show you a neat little JavaScript trick of using a modular operator. So we can check whether the index plus the total number of cocktails and we have to get the access to the total number of


02:04:49
cocktails by calling the all cocktails.length. So if the index that we're currently on plus the total cocktails is equally divisible by total cocktails and it returns a number that is not zero, well then we simply set it to the index. Else we'll return it to zero. So it'll restart once again once we reach the number that is greater than four. If that explanation wasn't clear, we can refer to the MDN docs checking the remainder operator which returns the leftover when one operand is divided by


02:05:22
the second one. So for example, if you try to evenly divide 13 by 5, you're going to get three because we can only divide 13 by 5 two times evenly, which is 10 and then 13 - 10 is 3. So if we evenly divide by four like this and then if our steps are zero and then we go to the second slide which is 1 2 3 and then once we reach four it'll actually bring us back to zero and then we restart from scratch. 1 2 3 4. Pretty cool, right? So, we have essentially created a slider that moves infinitely


02:06:04
to the right but resets at four. And if you want to learn more about the reminder operator or any other operator within the JavaScript language, well, we cover it in much more depth within the complete path to JavaScript mastery course. But for now, let's actually change the state so that it points to this new index. So, I'll say set current index to be equal to new index. Perfect. Now, if we test it out, you can see that you can choose a different cocktail with your mouse, but we don't yet have the


02:06:35
arrows to switch between them. So, let's do that next. Right below the nav element, I will create a new div and give it a class name equal to content. Within which I will then create a new div with a class name equal to arrows. Then within it, I'll create a new button. And this button will have a class name of text dash left. So we align it and an on click. It'll call the callback function where it'll go to slide that is current index minus one. And within it we can simply render the


02:07:15
previous cocktail name. So for now I'll just say prev cocktail name. Later on, we'll have to figure out what that cocktail name is. And then we can also render an image with a source of forward slash images slash right arrow.png with an al tag of right arrow and an area hidden of true. Great. So now we have this arrow right here. And you can see that it actually swaps between all these different cocktails. and it never stops. That's because we use the modulo operator. Now, we can repeat the same


02:07:55
thing by duplicating this button just below. This one will render the next cocktail name. So, I'll say next cocktail name. Go to slide current slide plus one instead of minus one. And I'll use the left arrow right here and call it left arrow. So now we have those two different buttons that allow us to switch between the cocktails left and right. Now let's go below this div that is containing these two buttons and let's render another div which will render the cocktail that we're trying to


02:08:30
show. It'll have a class name of cocktail and it'll render an image with a source of current cocktail image with a class name equal to object dash contain. But hey, how do we know which cocktail is the current one and which ones are previous and next ones? Well, let's figure that out. Right here at the top of our component, I will say const get cocktail at and then we have to get the index offset. Is it going to be the first, the second, the third and so on. And here we can automatically return all cocktails


02:09:17
where we get into the current index plus the index offset plus the total cocktails. And then we also use a modulo operator by the total cocktails. So at any point we know exactly which one is the current one, which one is the previous and which one is the next. With that in mind, we can extract those variables by saying const current cocktail is equal to get cocktail add zero. So that's the current one. Next, we can have the prev cocktail, which is going to be get cocktail add minus one. And then we can have the next cocktail


02:09:57
which is going to be get cocktail ad one. And now we can use this prev cocktail.name to show which cocktail we're going to go if we click on the left arrow. And here we can use the next cocktail.name to know where we're going to go for the next one. And here we can use the current cocktail image to show it. So now if we scroll down you'll be able to see that we have the coracal mojito and then we have the raspberry mojito if we go right and we can also see the image of the current one. Now I want to show


02:10:32
some more information about the cocktail that we're currently on. So just below this div that has a class name of cocktail I'll display another div that'll have a class name equal to recipe. This one will have a div and it'll have a reference pointing to the content ref because we want to animate this very soon. So right at the top I will create a new reference that we can attach to that recipe part of the cocktail menu. So I'll say use ref imported and then say const content ref


02:11:09
is equal to use ref imported from react. Perfect. This div will also have a class name equal to info and within it a p tag saying recipe for below it another p tag with an id of title that'll say current cocktail dot name and then below this div we can render some more details. So I'll render a div with a class name equal to details where we will render the H2 that'll render the current cocktail title and below it a p tag that'll render the current cocktail dot description. So, if we save this, you


02:11:53
can see that now at the bottom we have this info that says that this is a recipe for a classic mojito with simple ingredients made with tequila, lime juice, and orange liquor. So, this is looking so much better right away. Let's also check it out on desktop to see it in its full glory. Looks like the arrows are not positioned well. So if you hit back, looks like I called it arrow, but the class name needs to be arrows for it to get this flex item center and justify between styles. So if you change it,


02:12:24
you'll see that now it has a much nicer layout where we can actually click on these cocktails and immediately get new information or we can just click on the arrow or the name and immediately see the next one in line. Makes the choosing so simple. I think I'd go with this one right here. But now when we switch between different cocktail slides, we want to show a beautiful transition of a cocktail sliding from the left side to the center. And we also want to animate the text as it's sliding in. And here's


02:12:55
a little pro tip. I told you before that every single animation has to make sense outside of just looking cool. So in our case, the first one is to make them really interested into our bar where they can see all of the different drinks that we offer. Then we have this section right here which brings them even closer to ordering a drink by getting the barman to come towards them and offer it to them. And then finally with the menu, the goal is to make them feel as the drink is already sliding across the


02:13:25
table coming right toward them. That's going to make them super likely to order it. This is called emotion-driven design and it's used in a lot of different websites nowadays and it is particularly useful when it comes to animations because you don't want to implement the animation just for the sake of adding it. You want to add it to welcome the user to the jungle for example by moving these leaves up and down. You want to use them to make the users feel something. So let's add those


02:13:52
animations. First we'll animate this title. Then we will slide the drink across the table. Right at the top of our component, I'll use a use gab hook and I'll create a callback function as before, but this time I'll also provide something within the dependency array. And that's going to be the current index. Why? And what does this do? Well, when you provide something, a specific variable within the use gub hook dependency array, it'll rerun all of the animations that are within it whenever


02:14:27
this variable changes. So, whenever we change the slider from one cocktail to another, we want to rerun the animations for that other cocktail. So, let's start with animating the title by first importing GAP right at the top by saying import GAP from GSAP. And then we can say gap dot from two. We want to animate the title from the opacity of zero to the opacity of one throughout the duration of 1 second. So now if you click on one of these list items, you can see that the title slowly animates.


02:15:10
But of course, let's focus on the drink now. That's the main star of the show. So I'll say gap from 2C cocktail image. We want to start from the opacity of zero and most importantly the x% from minus 100 so that it's outside of the screen. And then we want to change the X percent to zero to bring it back to the middle of the screen with the opacity of one throughout the duration of 1 second and ease of power one and out. So if you save this, you can see that now the cocktails nicely slide in. And even


02:15:53
though we cannot see the bottom of the text right here, at least not on mobile devices, it is all fully visible on desktop. So let's animate it as well by saying gap dot from two dotdetails h2 from y% 100 and opacity of zero. We want to bring it to y% of zero and opacity of 100 with the ease of power one in out. And we can do the same thing for the p tag. So we'll duplicate this gap. 2 and change it from details to P tag. Perfect. Now if you move over to the second cocktail, you can see that


02:16:36
both the P tag and the H2 fly in from below to above. Of course, we want to check out how that looks like on desktop. So as I click it, you can see that it looks even better. It is super quick and just works so well. Oh, and if you want to, as an extra assignment for this section, you can also add a parallax effect to these leaves right here on bottom left and top right. So, they move slightly up and down, similarly to what we have done in the last two times. And with that in mind, we're done with the menu section. So, in


02:17:12
the next one, we can focus on the last section of this application, which is the footer section. But it won't be a very simple, boring footer section. We can actually make it as part of our contact page as well. So we can say where our bar is located, some contact information, as well as the opening hours and of course our socials. So let's do this next. And finally, we are ready to dive right into our footer, which is more than just a footer. It is also a contact page. So, back within our application, head over


02:17:48
into the components folder and create a new file and call it contact.jsx. Within it, runce. And let's just import it within the app.jsx by importing the contact section. If you do that, we can get started by creating it right away. I'll use a semantic HTML 5 footer tag and give it an ID of contact so we can very easily scroll to it. Right within it, I will display an image that has a source equal to and once again we're dealing with some leaves. So I'll say images footer write leaf.png PNG with an al tag of leaf


02:18:31
right and I'll also render an ID of F right leaf which we'll use to animate it very soon I'll duplicate it and change this over to a left leaf in all three instances and right below it we can render a div with a class name equal to content and within the content we can render an H2 to that'll say where to find us. Now, if you save this and scroll to the bottom, you can see the where to find us section. Now, I'll collapse this just so we can see it right here. And it looks like the left leaf didn't render


02:19:12
properly because I misspelled left. So, let's fix it in all three places. And now you can see both the left and the top leaves. Now, below this H2, let's render a div. And within it, let's say H3 visit our store or here we can say bar. Then below it, a P tag where we can render an address. I'll head back to the design so I can copy this random address in the US. Below it, we can render another div that'll say H3 of contact us. And then we can also paste the phone number which I will copy within a P tag


02:19:56
as well as the email address which will be right within another P tag. Finally, I'll render another div that'll have an H3 that says open every day. And then below it, we can map over the opening hours map where we get each individual time. And for each of these times, we can automatically return a P tag that'll have a key equal to time. And within it, we can render the time doday colon and then time dot time. So we render both day and the time. So if we head back now, we can see visit our


02:20:39
bar, contact us, and open everyday. We can head below this div and render one last div for our socials. So I'll render h3 and say socials. And within it, I will render another div with a class name equal to flex- center and a gap of five. And we will map over the socials right here which are coming from the constants. So make sure to import them. And for each one of our socials, we will automatically return an anchor tag. So we can actually visit it. That'll render the image with a source


02:21:21
of social. So if I save it, you can see three different icons. And now we can style them a bit by giving it a key of social.name. name an href of social. URL so we can point to it a target of underscore blank so it opens up in a new page and with it we have to provide a re of no opener no referral just like this and finally an area label for screen readers of social name so we know what we're clicking on. So now you can see that we have this footer section. If I expand it just a bit you'll see that it looks even


02:22:02
better. We now have those two leaves on the left and the right sides. And of course, we are ready to apply a couple of animations. I'll collapse our code just a bit just so we can see the entire part of the footer. And I'll head right at the top of this contact section where I will use the use gab hook. And we will run it just at the start. Within it, we want to split this title into multiple words by using the split text plugin. So I'll say const title split is equal to split text which we


02:22:37
have to import at the top by saying import split text coming from gap all and don't forget to import the gap library itself by saying import gap from gap on the split text we can call split text.create create and we pass what we want to split. So that's the H2 within the contact section and we want to split it into a type of words. Now that we've split it, we can create a timeline and tie it to the scroll position. So say timeline is equal to gap.timeline based on the scroll trigger and the


02:23:15
trigger will actually be once we reach the contact section. So the start will be once the top of the contact section reaches the center of the screen. And we can also define the easing. So that's going to look like this ease of power one in out. And that's our timeline. So now we can focus on actually animating different elements within that timeline. Specifically we can focus on animating each word in the title right here. So say timeline dot from we want to take the title split words and animate it from the opacity of zero


02:23:57
from the y% of 100 which is outside of the screen and with a stagger of 0.02. If you apply this and reload nothing will happen yet. That's because I said word right here instead of words. So, if you fix it and reload, you can see that it slowly starts coming up and down. We'll see it better once we go to full screen. But for now, let's focus on the other animations as well. So, I'll just chain another dot from to this timeline. This time, focusing on the contact H3 as well as the contact in the P tag. And


02:24:35
I'll do the same thing. Opacity zero, Y%, and stagger. And finally, we want to animate the leaves. So I'll say dot2. We want to go to hash f right leaf. Move it over by 50 pixels in the top direction throughout a duration of 1 second. And with an ease of power onein out and we can now duplicate this over for the f as in footer left leaf. So, if I save this, you'll see that now on scroll, those leaves move. But it'll be much easier to see it if we check out the full screen. Scroll


02:25:18
all the way to the top and reload. And now, nicely scroll to see our footer section. Let's go through the art through the menu. And finally, check this out. Where to find us? Everything nicely falls into the place. Although this leaf is not moving, that is the right leaf. So, let's see. F right leaf. How did we call it right here? Fight leaf. That is looking good to me. Oh, it looks like it does move but a bit later once everything else moves. So there's one trick that we can do and that is to


02:25:52
this timeline right after this dot 2 animation. So after we close this left thing, we can then add this little character that says before. What this means is that the element with ID F right leaf moves up by 50 pixels and at the same time the element with ID of F left leaf moves down by 50 pixels. So they move together. So now as I scroll you can see that this leaf right here just moved. And if I reload and check it out on mobile see how all of the elements of the footer nicely load but in this case there isn't enough


02:26:32
space to show the right leave here as well. So I just hide it. And that is it for the footer or the contact section. So what I'll do is close the files, open up my terminal and run git add dot getit commit-m implement contact section and then get push. So now the full application has been pushed over to GitHub. This has been such an amazing project. But now is where the real learning begins. Sure, we have implemented a couple of animations across all the different sections, but I need you to fully understand how GSAP


02:27:09
truly works behind the scenes. And I want you to be able to implement these complex animations on your own in your future applications that you will be working on, not just replicating what we did together in this course. Of course, building this project already gave you a nice foundation to build your GSA skills on top of, but now we're going to dive into the ultimate GSA course where we're going to dive deep into every single little GAP property so that you truly understand how it works behind the


02:27:41
scenes. Once again, congratulations on coming to the end of this course and developing this project. But now is where the real journey begins. Enjoy and congrats.

